<p>In the previous two installments of this OpenID Connect (OIDC) series, we dug deep into the <a href="https://developer.okta.com/blog/2017/07/25/oidc-primer-part-1">OIDC flow types</a> and saw <a href="https://developer.okta.com/blog/2017/07/25/oidc-primer-part-2">OIDC in action</a> using a playground found at: <a href="https://okta-oidc-fun.herokuapp.com/">https://okta-oidc-fun.herokuapp.com/</a>.</p>

<p>In this third and final installment, we’ll look at what’s encoded into the various types of tokens and how to control what gets put in them. JWTs, have the benefit of being able to carry information in them. With this information available to your app you can easily enforce token expiration and reduce the number of API calls. Additionally, since they’re cryptographically signed, you can verify that they have not been tampered with.</p>

<p>The source code that backs the site can be found at: <a href="https://github.com/oktadeveloper/okta-oidc-flows-example">https://github.com/oktadeveloper/okta-oidc-flows-example</a>.</p>

<p>There are two primary sources for information relating to identity as dictated by the OIDC spec. One source is the information encoded into the <code class="highlighter-rouge">id_token</code> <a href="https://tools.ietf.org/html/rfc7519">JWT</a>. Another is the response from the <code class="highlighter-rouge">/userinfo</code> endpoint, accessible using an <code class="highlighter-rouge">access_token</code> as a bearer token. At Okta, we’ve chosen to make our access tokens JWTs as well, which provides a third source of information. (You’ll see this in many OIDC implementations.)</p>

<p>There are a lot of combinations of query parameters in the <code class="highlighter-rouge">/authorization</code> request that determine what information will be encoded into an <code class="highlighter-rouge">id_token</code>. The two query parameters that impact what will ultimately be found in returned tokens and the <code class="highlighter-rouge">/userinfo</code> endpoint are <code class="highlighter-rouge">response_type</code> and <code class="highlighter-rouge">scope</code>.</p>

<h2 id="oidc-response-types">OIDC Response Types</h2>

<p>For the moment, we’ll set aside <code class="highlighter-rouge">scope</code> and focus on <code class="highlighter-rouge">response_type</code>. In the following examples, we use only the scopes, <code class="highlighter-rouge">openid</code> (required) and <code class="highlighter-rouge">email</code>. We’ll also work with the <a href="http://openid.net/specs/openid-connect-core-1_0.html#ImplicitFlowAuth">implicit flow</a>, since that gives us back tokens immediately.</p>

<p>Given this request:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/authorize?client_id=0oa2yrbf35Vcbom491t7&amp;response_type=token&amp;scope=openid+email&amp;state=aboard-insect-fresh-smile&amp;nonce=c96fa468-ca1b-46f0-8974-546f23f9ee6f&amp;redirect_uri=https%3A%2F%2Fokta-oidc-fun.herokuapp.com%2Fflow_result
</code></pre></div></div>

<p>Notice that <code class="highlighter-rouge">response_type=token</code> will yield us an <code class="highlighter-rouge">access_token</code>. A particular format is not required in the OIDC spec for access tokens, but at Okta we use JWTs. Looking inside the returned token, we see:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	"active": true,
	"scope": "openid email",
	"username": "okta_oidc_fun@okta.com",
	"exp": 1501531801,
	"iat": 1501528201,
	"sub": "okta_oidc_fun@okta.com",
	"aud": "test",
	"iss": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7",
	"jti": "AT.upPJqU-Ism6Fwt5Fpl8AhNAdoUeuMsEgJ_VxJ3WJ1hk",
	"token_type": "Bearer",
	"client_id": "0oa2yrbf35Vcbom491t7",
	"uid": "00u2yulup4eWbOttd1t7"
}
</code></pre></div></div>

<p>This is mainly <em>resource</em> information, including an expiration (<code class="highlighter-rouge">exp</code>) and a user id (<code class="highlighter-rouge">uid</code>).</p>

<p>If we want to get <em>identity</em> information for the user, we must hit the <code class="highlighter-rouge">/userinfo</code> endpoint using the <code class="highlighter-rouge">access_token</code> as a bearer token. Here’s what that looks like using <a href="https://httpie.org">HTTPie</a>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/userinfo Authorization:"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Ik93bFNJS3p3Mmt1Wk8zSmpnMW5Dc2RNelJhOEV1elY5emgyREl6X3RVRUkifQ..."
HTTP/1.1 200 OK
...
{
	"sub": "00u2yulup4eWbOttd1t7",
	"email": "okta_oidc_fun@okta.com",
	"email_verified": true
}
</code></pre></div></div>

<p>We get back the <code class="highlighter-rouge">sub</code>, <code class="highlighter-rouge">email</code> and <code class="highlighter-rouge">email_verified</code> claims. This is because of the default <code class="highlighter-rouge">scope=openid+email</code> from the original request. We’ll look at some more detailed responses in the scopes section.</p>

<p>Let’s try another request:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/authorize?client_id=0oa2yrbf35Vcbom491t7&amp;response_type=id_token&amp;scope=openid+email&amp;state=aboard-insect-fresh-smile&amp;nonce=c96fa468-ca1b-46f0-8974-546f23f9ee6f&amp;redirect_uri=https%3A%2F%2Fokta-oidc-fun.herokuapp.com%2Fflow_result
</code></pre></div></div>

<p>This time, I’m asking for an ID token by using <code class="highlighter-rouge">response_type=id_token</code>.  The response is a JWT (as required by the OIDC spec) with this information encoded into it:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	"sub": "00u2yulup4eWbOttd1t7",
	"email": "okta_oidc_fun@okta.com",
	"ver": 1,
	"iss": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7",
	"aud": "0oa2yrbf35Vcbom491t7",
	"iat": 1501528456,
	"exp": 1501532056,
	"jti": "ID.4Mmzy2kj5_B8nGZ_PT4dt8-fzu1tA2W3C5dbEF-N6Us",
	"amr": [
		"pwd"
	],
	"idp": "00o1zyyqo9bpRehCw1t7",
	"nonce": "c96fa468-ca1b-46f0-8974-546f23f9ee6f",
	"email_verified": true,
	"auth_time": 1501528157
}
</code></pre></div></div>

<p>Notice that we have the <code class="highlighter-rouge">sub</code> and <code class="highlighter-rouge">email</code>claims encoded directly in the JWT. In this type of implicit flow, we have no bearer token to use against the <code class="highlighter-rouge">/userinfo</code> endpoint, so the identity information is baked right into the JWT.</p>

<p>Finally, let’s look at the last type of implicit flow:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/authorize?client_id=0oa2yrbf35Vcbom491t7&amp;response_type=id_token+token&amp;scope=openid+email&amp;state=aboard-insect-fresh-smile&amp;nonce=c96fa468-ca1b-46f0-8974-546f23f9ee6f&amp;redirect_uri=https%3A%2F%2Fokta-oidc-fun.herokuapp.com%2Fflow_result
</code></pre></div></div>

<p>Here, we are requesting both an <code class="highlighter-rouge">id_token</code> and an <code class="highlighter-rouge">access_token</code> in the response.</p>

<p>Our <code class="highlighter-rouge">access_token</code> has the same claims as before. The <code class="highlighter-rouge">id_token</code> has the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	"sub": "00u2yulup4eWbOttd1t7",
	"email": "okta_oidc_fun@okta.com",
	"ver": 1,
	"iss": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7",
	"aud": "0oa2yrbf35Vcbom491t7",
	"iat": 1501528536,
	"exp": 1501532136,
	"jti": "ID.fyybPizTmYLoQR20vlR7mpo8WTxB7JwkxplMQom-Kf8",
	"amr": [
		"pwd"
	],
	"idp": "00o1zyyqo9bpRehCw1t7",
	"nonce": "c96fa468-ca1b-46f0-8974-546f23f9ee6f",
	"auth_time": 1501528157,
	"at_hash": "T7ij7o69gBtjo6bAJvaVBQ"
}
</code></pre></div></div>

<p>Notice that there’s <em>less</em> information in the <code class="highlighter-rouge">id_token</code> this time (in this case, there’s no <code class="highlighter-rouge">email_verified</code> claim). Because we also requested the <code class="highlighter-rouge">access_token</code>, it’s expected that we will get the rest of the available identity information (based on scope) from the <code class="highlighter-rouge">/userinfo</code> endpoint. In this case, it yields the same information as before when we only requested the <code class="highlighter-rouge">access_token</code></p>

<h2 id="oidc-scopes">OIDC Scopes</h2>

<p>Combining all the available scopes with all the possible response types yields a large set of information to present: 48 combinations, to be exact. First, I’ll enumerate what each scope yields and then we’ll look at a few real world examples combining <code class="highlighter-rouge">request_type</code> and <code class="highlighter-rouge">scope</code>.</p>

<p>The first thing to note is that the different scopes have an impact on the information encoded in an <code class="highlighter-rouge">id_token</code> and returned from the <code class="highlighter-rouge">/userinfo</code> endpoint. Here’s a table of scopes and resultant claims. More information can be found in <a href="http://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims">Section 5.4 of the OIDC Spec</a></p>

<table>
  <thead>
    <tr>
      <th>scope</th>
      <th>resultant claims</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>openid</td>
      <td>(required for all OIDC flows)</td>
    </tr>
    <tr>
      <td>profile</td>
      <td>name, family_name, given_name, middle_name, nickname, preferred_username</td>
    </tr>
    <tr>
      <td>profile (cont’d)</td>
      <td>profile, picture, website, gender, birthdate, zoneinfo, locale, updated_at</td>
    </tr>
    <tr>
      <td>email</td>
      <td>email, email_verified</td>
    </tr>
    <tr>
      <td>address</td>
      <td>address</td>
    </tr>
    <tr>
      <td>phone</td>
      <td>phone_number, phone_number_verified</td>
    </tr>
  </tbody>
</table>

<p>Let’s try each of our implicit flows with <em>all</em> the possible (default) scope types.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/authorize?client_id=0oa2yrbf35Vcbom491t7&amp;response_type=token&amp;scope=openid+profile+email+address+phone&amp;state=aboard-insect-fresh-smile&amp;nonce=c96fa468-ca1b-46f0-8974-546f23f9ee6f&amp;redirect_uri=https%3A%2F%2Fokta-oidc-fun.herokuapp.com%2Fflow_result
</code></pre></div></div>

<p>The only difference in the resultant <code class="highlighter-rouge">access_token</code> compared to before is that all the scopes are encoded into the <code class="highlighter-rouge">scp</code> array claim.</p>

<p>This time, when I use the <code class="highlighter-rouge">access_token</code> to hit the <code class="highlighter-rouge">/userinfo</code> endpoint, I get back more information:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/userinfo Authorization:"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Ik93bFNJS3p3Mmt1Wk8zSmpnMW5Dc2RNelJhOEV1elY5emgyREl6X3RVRUkifQ..."
HTTP/1.1 200 OK
...
{
	"sub": "00u2yulup4eWbOttd1t7",
	"name": "Okta OIDC Fun",
	"locale": "en-US",
	"email": "okta_oidc_fun@okta.com",
	"preferred_username": "okta_oidc_fun@okta.com",
	"given_name": "Okta OIDC",
	"family_name": "Fun",
	"zoneinfo": "America/Los_Angeles",
	"updated_at": 1499922371,
	"email_verified": true
}
</code></pre></div></div>

<p><strong>Note: While it’s not the complete list of claims defined from <code class="highlighter-rouge">profile</code> scope, it’s all the claims for which my user in Okta has a value.</strong></p>

<p>Let’s try just the <code class="highlighter-rouge">id_token</code> implicit flow (still with all the default scopes):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/authorize?client_id=0oa2yrbf35Vcbom491t7&amp;response_type=id_token&amp;scope=openid+profile+email+address+phone&amp;state=aboard-insect-fresh-smile&amp;nonce=c96fa468-ca1b-46f0-8974-546f23f9ee6f&amp;redirect_uri=https%3A%2F%2Fokta-oidc-fun.herokuapp.com%2Fflow_result
</code></pre></div></div>

<p>Here’s what’s encoded into the <code class="highlighter-rouge">id_token</code> I get back:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	"sub": "00u2yulup4eWbOttd1t7",
	"name": "Okta OIDC Fun",
	"locale": "en-US",
	"email": "okta_oidc_fun@okta.com",
	"ver": 1,
	"iss": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7",
	"aud": "0oa2yrbf35Vcbom491t7",
	"iat": 1501532222,
	"exp": 1501535822,
	"jti": "ID.Zx8EclaZmhSckGHOCRzOci2OaduksmERymi9-ad7ML4",
	"amr": [
		"pwd"
	],
	"idp": "00o1zyyqo9bpRehCw1t7",
	"nonce": "c96fa468-ca1b-46f0-8974-546f23f9ee6f",
	"preferred_username": "okta_oidc_fun@okta.com",
	"given_name": "Okta OIDC",
	"family_name": "Fun",
	"zoneinfo": "America/Los_Angeles",
	"updated_at": 1499922371,
	"email_verified": true,
	"auth_time": 1501528157
}
</code></pre></div></div>

<p>All the (available) identity information is encoded right into the token, since I don’t have a bearer token to hit the <code class="highlighter-rouge">/userinfo</code> endpoint with.</p>

<p>Finally, let’s try the last variant of the Implicit Flow: <code class="highlighter-rouge">response_type=id_token+token</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/authorize?client_id=0oa2yrbf35Vcbom491t7&amp;response_type=code+id_token+token&amp;scope=openid+profile+email+address+phone&amp;state=aboard-insect-fresh-smile&amp;nonce=c96fa468-ca1b-46f0-8974-546f23f9ee6f&amp;redirect_uri=https%3A%2F%2Fokta-oidc-fun.herokuapp.com%2Fflow_result
</code></pre></div></div>

<p>In this case, we have some of the claims encoded into the <code class="highlighter-rouge">id_token</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	"sub": "00u2yulup4eWbOttd1t7",
	"name": "Okta OIDC Fun",
	"email": "okta_oidc_fun@okta.com",
	"ver": 1,
	"iss": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7",
	"aud": "0oa2yrbf35Vcbom491t7",
	"iat": 1501532304,
	"exp": 1501535904,
	"jti": "ID.1C2NQext2hM0iJy55cLc_Ryc45urVYC1wJ0S-KebkpI",
	"amr": [
		"pwd"
	],
	"idp": "00o1zyyqo9bpRehCw1t7",
	"nonce": "c96fa468-ca1b-46f0-8974-546f23f9ee6f",
	"preferred_username": "okta_oidc_fun@okta.com",
	"auth_time": 1501528157,
	"at_hash": "GB5O9CpSSOUSfVZ9CRekRg",
	"c_hash": "mRNStYQm-QU4rwcfv88VKA"
}
</code></pre></div></div>

<p>If we use the resultant <code class="highlighter-rouge">access_token</code> to hit the <code class="highlighter-rouge">/userinfo</code> endpoint, in this case, we get back:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/userinfo Authorization:"Bearer eyJhbGciOiJSUzI1NiIsImtpZCI6Ik93bFNJS3p3Mmt1Wk8zSmpnMW5Dc2RNelJhOEV1elY5emgyREl6X3RVRUkifQ..."
HTTP/1.1 200 OK
...
{
	"sub": "00u2yulup4eWbOttd1t7",
	"name": "Okta OIDC Fun",
	"locale": "en-US",
	"email": "okta_oidc_fun@okta.com",
	"preferred_username": "okta_oidc_fun@okta.com",
	"given_name": "Okta OIDC",
	"family_name": "Fun",
	"zoneinfo": "America/Los_Angeles",
	"updated_at": 1499922371,
	"email_verified": true
}
</code></pre></div></div>

<p>This rounds out all the identity information that was requested in the scopes.</p>

<h2 id="custom-scopes-and-claims">Custom Scopes and Claims</h2>

<p>The OIDC spec accommodate custom scopes and claims. The ability to include custom claims in a token (which is cryptographically verifiable) is an important capability for identity providers. Okta’s implementation provides support for this.</p>

<p>The screenshot below shows my Authorization Server’s Claims tab:</p>

<p><img src="/assets/blog/oidc_primer/custom_claims_before-75085c61e8b267452bed424c6401f163a82ac4aee83a6dd7d8e3a0ebe2af4586.png" alt="custom claims" width="800" /></p>

<p>Clicking the “Add Claim” button brings up a dialog:</p>

<p><img src="/assets/blog/oidc_primer/full_name_custom_claim-9f9bd4630616f83b0550384dd82fc9ae25fecccdeb30d65ba5a5ef9d1e70683b.png" alt="full name" width="800" /></p>

<p>In the above screenshot, the custom claim is defined using Okta’s <a href="https://developer.okta.com/reference/okta_expression_language/">Expression Language</a>. Unique to Okta, the expression language is a flexible way to describe rules for building a property to include (or not) in custom claims.</p>

<p>Using the implicit flow with <code class="highlighter-rouge">response_type=id_token</code> and <code class="highlighter-rouge">scope=openid+profile</code>, we now get back an <code class="highlighter-rouge">id_token</code> with these claims encoded in it:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
	"sub": "00u2yulup4eWbOttd1t7",
	"ver": 1,
	"iss": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7",
	"aud": "0oa2yrbf35Vcbom491t7",
	"iat": 1501533536,
	"exp": 1501537136,
	"jti": "ID.TsKlBQfGmiJcl2X3EuhzyyLfmzqi0OCd66rJ3Onk7FI",
	"amr": [
		"pwd"
	],
	"idp": "00o1zyyqo9bpRehCw1t7",
	"nonce": "c96fa468-ca1b-46f0-8974-546f23f9ee6f",
	"auth_time": 1501528157,
	"at_hash": "hEjyn3mbKjuWanuSAF-z4Q",
	"full_name": "Okta OIDC Fun"
}
</code></pre></div></div>
<p>Notice the <code class="highlighter-rouge">full_name</code> claim present in the <code class="highlighter-rouge">id_token</code>.</p>

<h2 id="verifying-tokens">Verifying Tokens</h2>

<p>Access tokens can be verified by hitting the <code class="highlighter-rouge">/introspect</code> endpoint. For an <code class="highlighter-rouge">active</code> token, you get a response like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http --auth &lt;OIDC Client ID&gt;:&lt;OIDC Client Secret&gt; -f POST \
https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/introspect \
token=eyJhbGciOiJSUzI1NiIsImtpZCI6Ik93bFNJS3p3Mmt1Wk8zSmpnMW5Dc2RNelJhOEV1elY5emgyREl6X3RVRUkifQ...
HTTP/1.1 200 OK
...

{
    "active": true,
    "aud": "https://afitnerd.com/test",
    "client_id": "xdgqP32nYN148gn3gJsW",
    "exp": 1498517509,
    "fullName": "Micah Silverman",
    "iat": 1498513909,
    "iss": "https://micah.oktapreview.com/oauth2/aus9vmork8ww5twZg0h7",
    "jti": "AT.JdXQPAuh-JTqhspCL8nLe2WgbfjcK_-jmlp7zwaYttE",
    "scope": "openid profile",
    "sub": "micah+okta@afitnerd.com",
    "token_type": "Bearer",
    "uid": "00u9vme99nxudvxZA0h7",
    "username": "micah+okta@afitnerd.com"
}

</code></pre></div></div>

<p>Since it requires the OIDC client ID and secret, this operation would typically be done in an application server where it’s safe to have those credentials. You would not want something like an end-user web or mobile application to have access to the OIDC client secret.</p>

<p>If the <code class="highlighter-rouge">token</code> parameter is invalid or expired, the <code class="highlighter-rouge">/introspect</code> endpoint returns this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http --auth &lt;OIDC Client ID&gt;:&lt;OIDC Client Secret&gt; -f POST \
https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/introspect \
token=bogus
HTTP/1.1 200 OK
...
{
    "active": false
}
</code></pre></div></div>

<p>ID tokens can be verified using the <a href="https://tools.ietf.org/html/rfc7517">JWK</a> endpoint. JWK is a JSON data structure that represents a crypto key. The JWK endpoint is exposed from the OIDC “well known” endpoint used for API discovery. This returns <em>a lot</em> of information. Here’s an excerpt:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/.well-known/openid-configuration
HTTP/1.1 200 OK
...
{
    "authorization_endpoint": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/authorize",
	...
    "introspection_endpoint": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/introspect",
	...
    "issuer": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7",
    "jwks_uri": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/keys",
	...
    "userinfo_endpoint": "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/userinfo"
}
</code></pre></div></div>

<p>Some of the endpoints, such as <code class="highlighter-rouge">/userinfo</code> and <code class="highlighter-rouge">/authorize</code>, should look familiar by now. The one we’re interested in is the <code class="highlighter-rouge">/keys</code> endpoint shown in <code class="highlighter-rouge">jwks_uri</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7/v1/keys
HTTP/1.1 200 OK
...
{
    "keys": [
        {
            "alg": "RS256",
            "e": "AQAB",
            "kid": "cbkhWG0YmFsGiNO1LEkWSEszDCTNfwvJPpXxuVf_kX0",
            "kty": "RSA",
            "n": "g2XQgdyc5P6F4K26ioKiUzrdgfy90eBgIbcrKkspKZmzRJ3CIssv69f1ClJvT784J-...",
            "use": "sig"
        }
    ]
}
</code></pre></div></div>

<p>Notice the <code class="highlighter-rouge">kid</code> claim. It matches the <code class="highlighter-rouge">kid</code> claim in the header from our <code class="highlighter-rouge">id_token</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
 "typ": "JWT",
 "alg": "RS256",
 "kid": "cbkhWG0YmFsGiNO1LEkWSEszDCTNfwvJPpXxuVf_kX0"
}
</code></pre></div></div>

<p>We can also see that the algorithm used is <code class="highlighter-rouge">RS256</code>. Using the public key found in the <code class="highlighter-rouge">n</code> claim along with a security library, we can confirm that the ID token has not been tampered with. All of this can be done safely on an end-user SPA, mobile app, etc.</p>

<p>Here’s a Java example that uses the claims from the <code class="highlighter-rouge">jwks_uri</code> above to verify an <code class="highlighter-rouge">id_token</code>: <a href="https://github.com/dogeared/JWKTokenVerifier">https://github.com/dogeared/JWKTokenVerifier</a></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>java -jar target/jwk-token-verifier-0.0.1-SNAPSHOT-spring-boot.jar \
eyJhbGciOiJSUzI1NiIsImtpZCI6Ik93bFNJS3p3Mmt1Wk8zSmpnMW5Dc2RNel... \
g2XQgdyc5P6F4K26ioKiUzrdgfy90eBgIbcrKkspKZmzRJ3CIssv69f1ClJvT784J-... \
AQAB

Verified Access Token
{
  "header" : {
    "alg" : "RS256",
    "kid" : "cbkhWG0YmFsGiNO1LEkWSEszDCTNfwvJPpXxuVf_kX0"
  },
  "body" : {
    "ver" : 1,
    "jti" : "AT.LT9cRL_Kzd3T8Izw_ONZxHJ5xGBPD0m13iiEIDK_Nbw",
    "iss" : "https://micah.okta.com/oauth2/aus2yrcz7aMrmDAKZ1t7",
    "aud" : "test",
    "iat" : 1501533536,
    "exp" : 1501537136,
    "cid" : "0oa2yrbf35Vcbom491t7",
    "uid" : "00u2yulup4eWbOttd1t7",
    "scp" : [ "openid" ],
    "sub" : "okta_oidc_fun@okta.com"
  },
  "signature" : "ZV_9tYxt4v4bp9WEEDu038b7v_OHsbMZw13daR1s5_tI56oayBgJlnqf-..."
}
</code></pre></div></div>

<p>If any part of the <code class="highlighter-rouge">id_token</code> JWT had been tampered with, you would see this instead:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>io.jsonwebtoken.SignatureException: JWT signature does not match locally computed signature. JWT validity cannot be asserted and should not be trusted.
</code></pre></div></div>

<p>Verifying JWT’s using the <code class="highlighter-rouge">/introspect</code> endpoint and using JWKs is a powerful component of OIDC. It allows for a high degree of confidence that the token has not been tampered in any way. And, because of that, information contained within – such as expiration – can be safely enforced.</p>

<h2 id="how-i-learned-to-love-openid-connect">How I Learned to Love OpenID Connect</h2>

<p>When OIDC was first released and early implementers, such as Google, adopted it, I thought: “I just got used to OAuth 2.0. Why do I have to learn a new thing that rides on top of it?”</p>

<p>It took some time, but here is what I consider to be the important takeaways:</p>

<ul>
  <li>OIDC formalizes a number of things left open in OAuth 2.0. Things like: specific token formats (id_token) and specific scopes and claims.</li>
  <li>There’s explicit support for Authentication and Authorization. OAuth 2.0 was always presented purely as an authorization framework, but people would get confused with certain flows that allowed for authentication.</li>
  <li>There’s a clear separation between identity (<code class="highlighter-rouge">id_token</code> and <code class="highlighter-rouge">/userinfo</code>) and access to resources (<code class="highlighter-rouge">access_token</code>).</li>
  <li>The different flows provide clean use case implementations for mobile apps, SPAs, and traditional web apps.</li>
  <li>It’s inherently flexible. It’s easy to provide custom scopes and claims and to dictate what information should be encoded into tokens beyond the default specification.</li>
</ul>

<p>All the code used in this series can be found on <a href="https://github.com/oktadeveloper/okta-oidc-flows-example">github</a>. You can use the OIDC sample app to exercise the various flows and scopes discussed throughout these posts. It’s at: <a href="https://okta-oidc-fun.herokuapp.com/">https://okta-oidc-fun.herokuapp.com/</a>. The entire final OIDC spec can be found <a href="http://openid.net/specs/openid-connect-core-1_0.html">here</a>. And you can learn more about OAuth 2.0 at <a href="https://www.oauth.com/">oauth.com</a>.</p>

<p>The whole series is live now. Part 1 is <a href="https://developer.okta.com/blog/2017/07/25/oidc-primer-part-1">here</a>. Part 2 is <a href="https://developer.okta.com/blog/2017/07/25/oidc-primer-part-2">here</a>.</p>
